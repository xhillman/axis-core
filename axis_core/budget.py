"""Budget management for axis-core agents.

This module provides dataclasses for tracking resource consumption and enforcing limits.
"""

from dataclasses import dataclass


@dataclass(frozen=True)
class Budget:
    """Configuration for agent execution budget limits.

    Defines maximum resource consumption allowed during an agent run. All limits are
    enforced independently - hitting any single limit will stop execution.

    Attributes:
        max_cycles: Maximum number of observe-plan-act-evaluate cycles
        max_tool_calls: Maximum total tool invocations across all cycles
        max_model_calls: Maximum LLM API calls
        max_cost_usd: Maximum cost in USD
        max_wall_time_seconds: Maximum wall-clock time for execution
        max_input_tokens: Maximum input tokens sent to LLM (None = no limit)
        max_output_tokens: Maximum output tokens generated by LLM (None = no limit)
        warn_at_cost_usd: Cost threshold to trigger warnings (default: 80% of max)
    """

    max_cycles: int = 10
    max_tool_calls: int = 50
    max_model_calls: int = 20
    max_cost_usd: float = 1.00
    max_wall_time_seconds: float = 300.0
    max_input_tokens: int | None = None
    max_output_tokens: int | None = None
    warn_at_cost_usd: float = 0.80


@dataclass
class BudgetState:
    """Tracks actual resource consumption during agent execution.

    Mutable state object that accumulates usage metrics. Use in conjunction with a
    Budget to check remaining resources and detect budget exhaustion.

    Attributes:
        cycles: Number of completed observe-plan-act-evaluate cycles
        tool_calls: Total tool invocations
        model_calls: Total LLM API calls
        input_tokens: Total input tokens sent to LLM
        output_tokens: Total output tokens generated by LLM
        cost_usd: Total cost in USD
        wall_time_seconds: Total wall-clock time elapsed
    """

    cycles: int = 0
    tool_calls: int = 0
    model_calls: int = 0
    input_tokens: int = 0
    output_tokens: int = 0
    cost_usd: float = 0.0
    wall_time_seconds: float = 0.0

    @property
    def total_tokens(self) -> int:
        """Returns sum of input and output tokens."""
        return self.input_tokens + self.output_tokens

    def cost_remaining_usd(self, budget: Budget) -> float:
        """Returns remaining cost budget in USD (minimum 0)."""
        return max(0.0, budget.max_cost_usd - self.cost_usd)

    def cycles_remaining(self, budget: Budget) -> int:
        """Returns remaining cycles (minimum 0)."""
        return max(0, budget.max_cycles - self.cycles)

    def tool_calls_remaining(self, budget: Budget) -> int:
        """Returns remaining tool calls (minimum 0)."""
        return max(0, budget.max_tool_calls - self.tool_calls)

    def model_calls_remaining(self, budget: Budget) -> int:
        """Returns remaining model calls (minimum 0)."""
        return max(0, budget.max_model_calls - self.model_calls)

    def is_exhausted(self, budget: Budget) -> bool:
        """Returns True if any budget limit has been reached or exceeded.

        Checks all configured limits. Token limits are only checked if they are
        set (not None) in the budget.
        """
        # Check always-present limits
        if self.cycles >= budget.max_cycles:
            return True
        if self.tool_calls >= budget.max_tool_calls:
            return True
        if self.model_calls >= budget.max_model_calls:
            return True
        if self.cost_usd >= budget.max_cost_usd:
            return True
        if self.wall_time_seconds >= budget.max_wall_time_seconds:
            return True

        # Check optional token limits
        if budget.max_input_tokens is not None and self.input_tokens >= budget.max_input_tokens:
            return True
        if (
            budget.max_output_tokens is not None
            and self.output_tokens >= budget.max_output_tokens
        ):
            return True

        return False

    def should_warn(self, budget: Budget) -> bool:
        """Returns True if cost has reached or exceeded the warning threshold."""
        return self.cost_usd >= budget.warn_at_cost_usd
